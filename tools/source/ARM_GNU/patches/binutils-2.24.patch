diff -Naur binutils-2.24/binutils/Makefile.in binutils-2.24_modded/binutils/Makefile.in
--- binutils-2.24/binutils/Makefile.in	2013-11-05 02:33:37 +1100
+++ binutils-2.24_modded/binutils/Makefile.in	2013-12-06 15:47:15 +1100
@@ -1462,19 +1462,19 @@
 	    $(LIBTOOL)  --mode=install $(INSTALL_PROGRAM) $$p$(EXEEXT) $(DESTDIR)$(bindir)/`echo $$p|sed -e 's/-new//' -e 's/cxxfilt/$(DEMANGLER_NAME)/'|sed '$(transform)'|sed 's/$$/$(EXEEXT)/'`; \
 	  else :; fi; \
 	done
-	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
-	for i in $(TOOL_PROGS); do \
-	  if [ -f $$i$(EXEEXT) ]; then \
-	    j=`echo $$i | sed -e 's/-new//'`; \
-	    k=`echo $$j | sed '$(transform)'`; \
-	    if [ "$(bindir)/$$k" != "$(tooldir)/bin/$$j" ]; then \
-	      rm -f $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT); \
-	      ln $(DESTDIR)$(bindir)/$$k$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT) >/dev/null 2>/dev/null \
-		|| $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) $$i$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT); \
-	    fi; \
-	  else true; \
-	  fi; \
-	done
+#	$(mkinstalldirs) $(DESTDIR)$(tooldir)/bin
+#	for i in $(TOOL_PROGS); do \
+#	  if [ -f $$i$(EXEEXT) ]; then \
+#	    j=`echo $$i | sed -e 's/-new//'`; \
+#	    k=`echo $$j | sed '$(transform)'`; \
+#	    if [ "$(bindir)/$$k" != "$(tooldir)/bin/$$j" ]; then \
+#	      rm -f $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT); \
+#	      ln $(DESTDIR)$(bindir)/$$k$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT) >/dev/null 2>/dev/null \
+#		|| $(LIBTOOL) --mode=install $(INSTALL_PROGRAM) $$i$(EXEEXT) $(DESTDIR)$(tooldir)/bin/$$j$(EXEEXT); \
+#	    fi; \
+#	  else true; \
+#	  fi; \
+#	done
 
 # Tell versions [3.59,3.63) of GNU make to not export all variables.
 # Otherwise a system limit (for SysV at least) may be exceeded.
diff -Naur binutils-2.24/binutils/dwarf.c binutils-2.24_modded/binutils/dwarf.c
--- binutils-2.24/binutils/dwarf.c	2013-11-08 10:13:48 +0000
+++ binutils-2.24_modded/binutils/dwarf.c	2014-04-01 10:53:36 +0100
@@ -6696,6 +6696,10 @@
     }
 }
 
+#if defined (__MINGW32__)
+extern char *optarg;
+#endif
+
 void
 dwarf_select_sections_by_letters (const char *letters)
 {
diff -Naur binutils-2.24/binutils/rename.c binutils-2.24_modded/binutils/rename.c
--- binutils-2.24/binutils/rename.c	2013-11-04 15:33:37 +0000
+++ binutils-2.24_modded/binutils/rename.c	2014-04-09 11:49:02 +0100
@@ -21,6 +21,9 @@
 #include "sysdep.h"
 #include "bfd.h"
 #include "bucomm.h"
+#if defined (_WIN32) && !defined (__CYGWIN32__)
+#include "windows.h"
+#endif /* if defined (_WIN32) && !defined (__CYGWIN32__) */
 
 #ifdef HAVE_GOOD_UTIME_H
 #include <utime.h>
@@ -131,6 +134,16 @@
 #endif
 #endif
 
+#if defined (_WIN32) && !defined (__CYGWIN32__)
+BOOL FileExists(LPCTSTR szPath)
+{
+  DWORD dwAttrib = GetFileAttributes(szPath);
+
+  return (dwAttrib != INVALID_FILE_ATTRIBUTES && 
+         !(dwAttrib & FILE_ATTRIBUTE_DIRECTORY));
+}
+#endif /* if defined (_WIN32) && !defined (__CYGWIN32__) */
+
 /* Rename FROM to TO, copying if TO is a link.
    Return 0 if ok, -1 if error.  */
 
@@ -150,7 +163,15 @@
   if (exists)
     remove (to);
 
-  ret = rename (from, to);
+  /* On Windows this rename sometimes fails with error "File exists" for no reason - retry it if necessary. */ 
+  int retry_count = 0;
+  do
+  {
+    ret = rename (from, to);
+	retry_count++;
+  } while ( ( FileExists(to) == 0 ) && (ret != 0) && (retry_count < 20));
+
+  
   if (ret != 0)
     {
       /* We have to clean up here.  */
diff -Naur binutils-2.24/config/override.m4 binutils-2.24_modded/config/override.m4
--- binutils-2.24/config/override.m4	2013-11-05 02:33:37 +1100
+++ binutils-2.24_modded/config/override.m4	2013-12-06 15:47:15 +1100
@@ -29,7 +29,7 @@
 
 dnl Ensure exactly this Autoconf version is used
 m4_ifndef([_GCC_AUTOCONF_VERSION],
-  [m4_define([_GCC_AUTOCONF_VERSION], [2.64])])
+  [m4_define([_GCC_AUTOCONF_VERSION], [2.69])])
 
 dnl Test for the exact version when AC_INIT is expanded.
 dnl This allows to update the tree in steps (for testing)
diff -Naur binutils-2.24/gas/Makefile.in binutils-2.24_modded/gas/Makefile.in
--- binutils-2.24/gas/Makefile.in	2013-11-05 02:33:37 +1100
+++ binutils-2.24_modded/gas/Makefile.in	2013-12-06 15:47:15 +1100
@@ -2591,7 +2591,7 @@
 .PHONY: install-exec-local install-data-local
 .PHONY: install-exec-bindir install-exec-tooldir
 
-install-exec-local: install-exec-bindir @install_tooldir@
+install-exec-local: install-exec-bindir
 
 install-exec-bindir: $(noinst_PROGRAMS)
 	$(mkinstalldirs) $(DESTDIR)$(bindir)
diff -Naur binutils-2.24/ld/ldgram.y binutils-2.24_modded/ld/ldgram.y
--- binutils-2.24/ld/ldgram.y	2013-11-05 02:33:39 +1100
+++ binutils-2.24_modded/ld/ldgram.y	2013-12-06 15:52:35 +1100
@@ -41,6 +41,9 @@
 #include "ldctor.h"
 #include "ldlex.h"
 
+#define YYDEBUG 1
+#define YYERROR_VERBOSE 1
+
 #ifndef YYDEBUG
 #define YYDEBUG 1
 #endif
@@ -97,6 +100,7 @@
 %type <flag_info> sect_flags
 %type <name> memspec_opt casesymlist
 %type <name> memspec_at_opt
+%type <name> memspec_ovfl_opt
 %type <cname> wildcard_name
 %type <wildcard> wildcard_spec
 %token <bigint> INT
@@ -144,7 +148,7 @@
 %token STARTUP HLL SYSLIB FLOAT NOFLOAT NOCROSSREFS
 %token ORIGIN FILL
 %token LENGTH CREATE_OBJECT_SYMBOLS INPUT GROUP OUTPUT CONSTRUCTORS
-%token ALIGNMOD AT SUBALIGN HIDDEN PROVIDE PROVIDE_HIDDEN AS_NEEDED
+%token ALIGNMOD AT OVERFLOW_INTO SUBALIGN HIDDEN PROVIDE PROVIDE_HIDDEN AS_NEEDED
 %type <token> assign_op atype attributes_opt sect_constraint opt_align_with_input
 %type <name>  filename
 %token CHIP LIST SECT ABSOLUTE  LOAD NEWLINE ENDWORD ORDER NAMEWORD ASSERT_K
@@ -1020,6 +1024,12 @@
         |       { $$ = 0; }
         ;
 
+memspec_ovfl_opt:
+                OVERFLOW_INTO '>' NAME { $$ = $3; /* overflow method 1 */ }
+        |       { $$ = 0; /* overflow method 2 */  }
+        ;
+
+
 opt_at:
 		AT '(' exp ')' { $$ = $3; }
 	|	{ $$ = 0; }
@@ -1062,10 +1072,10 @@
 			}
 		statement_list_opt
  		'}' { ldlex_popstate (); ldlex_expression (); }
-		memspec_opt memspec_at_opt phdr_opt fill_opt
+		memspec_opt memspec_at_opt phdr_opt fill_opt memspec_ovfl_opt
 		{
 		  ldlex_popstate ();
-		  lang_leave_output_section_statement ($18, $15, $17, $16);
+		  lang_leave_output_section_statement ($18, $15, $17, $16, $19);
 		}
 		opt_comma
 		{}
@@ -1080,11 +1090,11 @@
 		overlay_section
 		'}'
 			{ ldlex_popstate (); ldlex_expression (); }
-		memspec_opt memspec_at_opt phdr_opt fill_opt
+		memspec_opt memspec_at_opt phdr_opt fill_opt memspec_ovfl_opt
 			{
 			  ldlex_popstate ();
 			  lang_leave_overlay ($5, (int) $4,
-					      $16, $13, $15, $14);
+					      $16, $13, $15, $14, $17);
 			}
 		opt_comma
 	|	/* The GROUP case is just enough to support the gcc
diff -Naur binutils-2.24/ld/ldlang.c binutils-2.24_modded/ld/ldlang.c
--- binutils-2.24/ld/ldlang.c	2013-11-05 02:33:39 +1100
+++ binutils-2.24_modded/ld/ldlang.c	2013-12-06 15:47:15 +1100
@@ -67,6 +67,15 @@
 static lang_statement_list_type *stat_save[10];
 static lang_statement_list_type **stat_save_ptr = &stat_save[0];
 static struct unique_sections *unique_section_list;
+static bfd_vma
+lang_size_sections_1
+  (lang_statement_union_type **head_ptr,
+   lang_statement_union_type ***tail_ptr,
+   lang_output_section_statement_type *output_section_statement,
+   fill_type *fill,
+   bfd_vma dot,
+   bfd_boolean *relax,
+   bfd_boolean check_regions);
 
 /* Forward declarations.  */
 static void exp_init_os (etree_type *);
@@ -945,8 +954,11 @@
 	  break;
 	case lang_output_section_statement_enum:
 	  if (s->output_section_statement.constraint != -1)
+	  {
+//		  printf("\nprocessing output section %s\n\n", s->output_section_statement.name);
 	    lang_for_each_statement_worker
 	      (func, s->output_section_statement.children.head);
+	  }
 	  break;
 	case lang_wild_statement_enum:
 	  lang_for_each_statement_worker (func,
@@ -1813,11 +1825,11 @@
 				? after->lma_region->name_list.name
 				: NULL);
       lang_leave_output_section_statement (NULL, region, after->phdrs,
-					   lma_region);
+					   lma_region, NULL);
     }
   else
     lang_leave_output_section_statement (NULL, DEFAULT_MEMORY_REGION, NULL,
-					 NULL);
+					 NULL, NULL);
 
   if (ps != NULL && *ps == '\0')
     {
@@ -3695,6 +3707,7 @@
 	     statement in the sequence we may be about to move.  */
 	  os = &(*s)->output_section_statement;
 
+//	  printf("process_insert_statements: os = %s last_os = %s, last_os->next = %s\n", os->name, (last_os)?last_os->name:"Null", (last_os && last_os->next)?last_os->next->name:"Null");
 	  ASSERT (last_os == NULL || last_os->next == os);
 	  last_os = os;
 
@@ -4753,11 +4766,337 @@
     }
 }
 
+char * statement_types[] = {
+	"output_section",
+	"assignment_",
+	"input",
+	"address",
+	"wild",
+	"input_section",
+	"object_symbols",
+	"fill",
+	"data",
+	"reloc",
+	"target",
+	"output",
+	"padding",
+	"group",
+	"insert",
+	"constructors",
+};
+
+static void print_chain( lang_statement_union_type* sect_list, char* prefix )
+{
+	lang_statement_union_type *s;
+	for (s = sect_list; s != NULL; s = s->header.next)
+	{
+		printf("%sstatement: %s", prefix, statement_types[s->header.type] );
+		if ( s->header.type == lang_input_section_enum )
+		{
+			printf( " %s", ((lang_input_section_type*)s)->section->name );
+		}
+		else if ( s->header.type == lang_output_section_statement_enum )
+		{
+			printf( " %s", ((lang_output_section_statement_type*)s)->name );
+			printf("\n");
+			print_chain( ((lang_output_section_statement_type*)s)->children.head, "  " );
+		}
+		printf("\n");
+    }
+}
+
+static void
+verify_chain
+  (lang_statement_union_type **orig_list_head_ptr,
+		  lang_output_section_statement_type * output_section,
+		  asection * prev_input_section)
+{
+	if ( orig_list_head_ptr == NULL )
+	{
+		printf( "list head address is null\n");
+		ASSERT(0);
+	}
+
+	lang_statement_union_type * curr_statement = *orig_list_head_ptr;
+	lang_statement_union_type * prev_statement = NULL;
+
+	while ( curr_statement != NULL )
+	{
+		if ( ( prev_statement ) && ( prev_statement->header.next != curr_statement ) )
+		{
+			printf( "previous item next pointer not as expected" );
+			ASSERT(0);
+		}
+
+		switch  ( curr_statement->header.type )
+		{
+			case lang_input_section_enum:
+			{
+//				printf("input section %s\n",curr_statement->input_section.section->name );
+//				if ( curr_statement->input_section.section->prev != prev_input_section )
+//				{
+//					printf( "input section %s prev pointer not as expected\n", curr_statement->input_section.section->name );
+//					printf( "expected %s but got %s\n", prev_input_section->name, curr_statement->input_section.section->prev->name );
+//					ASSERT(0);
+//				}
+
+				asection * tmp = curr_statement->input_section.section;
+				while ( tmp != NULL )
+				{
+//					printf("is %s\n", tmp->name);
+					tmp = tmp->next;
+				}
+
+
+//				if ( (prev_input_section) && (prev_input_section->next != curr_statement->input_section.section ) )
+//				{
+//					printf( "previous input section %s next pointer not as expected\n", prev_input_section->name );
+//					printf( "expected %s but got %s\n", curr_statement->input_section.section->name, prev_input_section->next->name );
+//					ASSERT(0);
+//				}
+
+				if ( curr_statement->input_section.section->output_section != output_section->bfd_section )
+				{
+					printf( "wrong output section\n" );
+					printf( "expecting %s got %s\n", output_section->bfd_section->name, curr_statement->input_section.section->output_section->name );
+					ASSERT(0);
+				}
+
+				prev_input_section = curr_statement->input_section.section;
+			}
+			break;
+			case lang_assignment_statement_enum:
+			break;
+			case lang_padding_statement_enum:
+			break;
+			case lang_wild_statement_enum:
+			{
+//				verify_chain( &curr_statement->wild_statement.children.head, output_section, prev_input_section );
+			}
+			break;
+			default:
+			{
+				printf("unhandled header type %d\n", curr_statement->header.type);
+				ASSERT(0);
+			}
+			break;
+		}
+		prev_statement = curr_statement;
+		curr_statement = curr_statement->header.next;
+	}
+//	printf("successfully verified output section %s\n", output_section->name);
+}
+//lang_output_section_statement_enum,
+//lang_assignment_statement_enum,
+//lang_input_statement_enum,
+//lang_address_statement_enum,
+//lang_wild_statement_enum,
+//lang_input_section_enum,
+//lang_object_symbols_statement_enum,
+//lang_fill_statement_enum,
+//lang_data_statement_enum,
+//lang_reloc_statement_enum,
+//lang_target_statement_enum,
+//lang_output_statement_enum,
+//lang_padding_statement_enum,
+//lang_group_statement_enum,
+//lang_insert_statement_enum,
+//lang_constructors_statement_enum
+
+
+static int
+size_input_section_overflow_if_required
+  (lang_statement_union_type **orig_list_head_ptr,
+   lang_statement_union_type ***orig_list_tail_ptr,
+   lang_output_section_statement_type *_orig_output_section_statement,
+   lang_statement_union_type ** orig_current_statement_in,
+//   fill_type *fill,
+   bfd_vma dot,
+   bfd_vma newdot,
+   bfd_boolean *relax,
+   bfd_boolean check_regions)
+{
+	if ( ( _orig_output_section_statement->ovfl_section ) &&
+         ( ( ( newdot < _orig_output_section_statement->region->origin ) ||
+		     ( newdot - _orig_output_section_statement->region->origin > _orig_output_section_statement->region->length)
+		   ) &&
+		   ( (newdot != _orig_output_section_statement->region->origin + _orig_output_section_statement->region->length) ||
+			 (_orig_output_section_statement->bfd_section->vma == 0)
+		   )
+		 )
+	   )
+	  {
+
+		  lang_output_section_statement_type* ovfl_section = lang_output_section_statement_lookup (_orig_output_section_statement->ovfl_section, 0, FALSE);
+
+		  if ( ovfl_section == NULL )
+		  {
+			  einfo (_("%F%P: Unknown Overflow section %s\n"), _orig_output_section_statement->ovfl_section);
+			  return 0;
+		  }
+
+
+//		  verify_chain ( &_orig_output_section_statement->children.head, _orig_output_section_statement, NULL );
+//		  verify_chain ( &ovfl_section->children.head, ovfl_section, NULL );
+
+		  lang_statement_union_type * orig_current_statement = *orig_current_statement_in;
+			/* Advance 'current' item pointer to end of chain since chain has been truncated. */
+			while ( (*orig_current_statement_in)->header.next != NULL )
+			{
+				*orig_current_statement_in = (*orig_current_statement_in)->header.next;
+			}
+
+		  printf ("Region %s overflowed as requested from %s into %s - current size %d, size limit %d, tried to add %d bytes\n",
+							   _orig_output_section_statement->region->name_list.name,
+							   _orig_output_section_statement->name,
+							   _orig_output_section_statement->ovfl_section,
+							   (int)(dot - _orig_output_section_statement->region->origin),
+							   (int)_orig_output_section_statement->region->length,
+							   (int)(newdot - dot) );
+
+
+
+
+//		  printf ("list at start:\n");
+//		  print_chain( *head_ptr, "" );
+
+
+		  /* Initialise the overflow output section if it has not been done already */
+		  if (ovfl_section->bfd_section == NULL)
+		    init_os (ovfl_section, _orig_output_section_statement->bfd_section->flags);
+
+
+		  /* Find previous statement in original list */
+		  lang_statement_union_type * orig_list_prev_statement = *orig_list_head_ptr;
+		  while ( (orig_list_prev_statement != orig_current_statement ) && ( orig_list_prev_statement->header.next != orig_current_statement ) )
+		  {
+			  orig_list_prev_statement = orig_list_prev_statement->header.next;
+		  }
+
+		  int curr_is_only_in_orig_list = ( orig_list_prev_statement == orig_current_statement );
+
+		  /* Find the last statement in ovfl_section */
+		  lang_statement_union_type * ovfl_last_statement = ovfl_section->children.head;
+		  int ovfl_list_is_empty = ( ovfl_last_statement == NULL );
+		  while ( ( ovfl_last_statement != NULL ) && ( ovfl_last_statement->header.next != NULL ) )
+		  {
+			  ovfl_last_statement = ovfl_last_statement->header.next;
+		  }
+
+		  /* Truncate the current output section to prevent region overflow */
+		  if ( curr_is_only_in_orig_list )
+		  {
+			  /* current statement is the only one in the output section
+			   * Wipe this ouptut section as the statement will be moved */
+			  *orig_list_head_ptr = NULL;
+			  *orig_list_tail_ptr = NULL;
+		  }
+		  else
+		  {
+			  /* Cut the linked list before current statement */
+			  orig_list_prev_statement->header.next = NULL;
+			  *orig_list_tail_ptr = &orig_list_prev_statement->header.next;
+		  }
+
+
+		  if ( ovfl_list_is_empty )
+		  {
+			  /* Initialise the list to the grafted item */
+			  ovfl_section->children.head = orig_current_statement;
+
+			  /* Point the overflow section tail to the statement being grafted */
+			  ovfl_section->children.tail = &orig_current_statement->header.next;
+
+			  /* Cut the BFD forward link to the grafted statement from the original previous statement */
+//  			  if ( (*orig_current_statement)->input_section.section->prev )
+//  			  {
+//  				  (*orig_current_statement)->input_section.section->prev->next = NULL;
+//  			  }
+
+			  /* Zero the BFD backward link of the grafted statement */
+//			  (*orig_current_statement)->input_section.section->prev = NULL;
+
+		  }
+		  else
+		  {
+			  /* Point the overflow section tail to the statement being grafted */
+			  *ovfl_section->children.tail = orig_current_statement;
+			  ovfl_section->children.tail = &orig_current_statement->header.next;
+
+			  /* Cut the BFD forward link to the grafted statement from the original previous statement */
+//			  if ( (*orig_current_statement)->input_section.section->prev )
+//			  {
+//				  (*orig_current_statement)->input_section.section->prev->next = NULL;
+//			  }
+
+			  /* Point the BFD backward link of the grafted statement to the last item in the overflow section */
+//			  (*orig_current_statement)->input_section.section->prev = ovfl_last_statement->input_section.section;
+
+		  }
+
+
+		  /* Graft remaining part of output section onto the specified overflow section */
+//				  lang_statement_union_type * orig_tail = *output_section_statement->ovfl_section->children.tail;
+
+//		  printf ("list after graft start:\n");
+//		  print_chain( *head_ptr, "" );
+
+
+
+
+		  /* The items that have been moved to the overflow list still point to their old BFD output section. Change these pointers to the overflow section */
+		  lang_statement_union_type * overflowed_list_curr_statement = ovfl_section->children.head;
+		  while ( overflowed_list_curr_statement->header.next != NULL )
+		  {
+			  if (overflowed_list_curr_statement->header.type == lang_input_section_enum)
+			  {
+				  overflowed_list_curr_statement->input_section.section->output_section =  ovfl_section->bfd_section;
+//				  printf("%s\n", overflowed_list_curr_statement->input_section.section->name);
+			  }
+			  overflowed_list_curr_statement = overflowed_list_curr_statement->header.next;
+		  }
+		  if (overflowed_list_curr_statement->header.type == lang_input_section_enum)
+		  {
+			  overflowed_list_curr_statement->input_section.section->output_section =  ovfl_section->bfd_section;
+		  }
+
+		  /* Update the overflow section tail pointer to the new end of list */
+		  ovfl_section->children.tail = &orig_list_prev_statement->header.next;
+
+//		  printf ("overflowed chain:\n");
+//		  print_chain( ovfl_section->children.head, "" );
+
+		  /* The output section that had statements added may have already been sized - resize it */
+//		  if (ovfl_section->bfd_section != NULL)
+//		  {
+//			lang_size_sections_1 (&ovfl_section, NULL, abs_output_section,
+//					ovfl_section->fill, 0, relax, check_regions);
+//		  }
+
+//		*s = NULL;
+
+		return 1;
+	}
+	return 0;
+}
+
+//static void move_input_sections( sect_list )
+//{
+//	lang_statement_union_type *s;
+//	for (s = sect_list; s != NULL; s = s->header.next)
+//	{
+//
+//	}
+//}
+
 /* Set the sizes for all the output sections.  */
 
+static int indent = 0;
+
 static bfd_vma
 lang_size_sections_1
-  (lang_statement_union_type **prev,
+  (lang_statement_union_type **head_ptr,
+   lang_statement_union_type ***tail_ptr,
    lang_output_section_statement_type *output_section_statement,
    fill_type *fill,
    bfd_vma dot,
@@ -4766,8 +5105,15 @@
 {
   lang_statement_union_type *s;
 
+  lang_statement_union_type **start = head_ptr;
+
+  bfd_vma new_dot = dot;
+  char bfd_section_size_needs_update = 0;
+
+  indent++;
+
   /* Size up the sections from their constituent parts.  */
-  for (s = *prev; s != NULL; s = s->header.next)
+  for (s = *head_ptr; s != NULL; s = s->header.next)
     {
       switch (s->header.type)
 	{
@@ -4921,7 +5267,7 @@
 		os->bfd_section->output_offset = 0;
 	      }
 
-	    lang_size_sections_1 (&os->children.head, os,
+	    lang_size_sections_1 (&os->children.head, &os->children.tail, os,
 				  os->fill, newdot, relax, check_regions);
 
 	    os->processed_vma = TRUE;
@@ -5057,6 +5403,21 @@
 	    if (os->region != NULL
 		&& (os->bfd_section->flags & (SEC_ALLOC | SEC_LOAD)))
 	      {
+
+//		if ( os->ovfl_section)
+//		{
+//			  if ( ( ( dot < os->region->origin ) ||
+//			         ( dot - os->region->origin > os->region->length)
+//			       ) &&
+//			       ( (dot != os->region->origin + os->region->length) ||
+//			         (os->bfd_section->vma == 0)
+//			       )
+//			     )
+//			  {
+//				  printf ("overflowing %s - size %d, containing %d\n",);
+//			  }
+//		}
+
 		os->region->current = dot;
 
 		if (check_regions)
@@ -5075,11 +5436,12 @@
 				       os->bfd_section->lma);
 		  }
 	      }
+//	    printf( "finished output section %s size:%d\n", os->name, (int)os->bfd_section->size );
 	  }
 	  break;
 
 	case lang_constructors_statement_enum:
-	  dot = lang_size_sections_1 (&constructor_list.head,
+		new_dot = lang_size_sections_1 (&constructor_list.head, &constructor_list.tail,
 				      output_section_statement,
 				      fill, dot, relax, check_regions);
 	  break;
@@ -5117,10 +5479,8 @@
 	      }
 	    if (size < TO_SIZE ((unsigned) 1))
 	      size = TO_SIZE ((unsigned) 1);
-	    dot += TO_ADDR (size);
-	    output_section_statement->bfd_section->size
-	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);
-
+	    new_dot = dot + TO_ADDR (size);
+	    bfd_section_size_needs_update = 1;
 	  }
 	  break;
 
@@ -5133,14 +5493,13 @@
 	    s->reloc_statement.output_section =
 	      output_section_statement->bfd_section;
 	    size = bfd_get_reloc_size (s->reloc_statement.howto);
-	    dot += TO_ADDR (size);
-	    output_section_statement->bfd_section->size
-	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);
+	    new_dot = dot + TO_ADDR (size);
+	    bfd_section_size_needs_update = 1;
 	  }
 	  break;
 
 	case lang_wild_statement_enum:
-	  dot = lang_size_sections_1 (&s->wild_statement.children.head,
+	  dot = lang_size_sections_1 (&s->wild_statement.children.head, &s->wild_statement.children.tail,
 				      output_section_statement,
 				      fill, dot, relax, check_regions);
 	  break;
@@ -5168,7 +5527,9 @@
 		if (again)
 		  *relax = TRUE;
 	      }
-	    dot = size_input_section (prev, output_section_statement,
+
+
+	    new_dot = size_input_section (head_ptr, output_section_statement,
 				      output_section_statement->fill, dot);
 	  }
 	  break;
@@ -5251,7 +5612,7 @@
 				== bfd_target_elf_flavour)))
 		      output_section_statement->bfd_section->flags |= SEC_ALLOC;
 		  }
-		dot = newdot;
+		new_dot = newdot;
 	      }
 	  }
 	  break;
@@ -5274,7 +5635,7 @@
 	  break;
 
 	case lang_group_statement_enum:
-	  dot = lang_size_sections_1 (&s->group_statement.children.head,
+		new_dot = lang_size_sections_1 (&s->group_statement.children.head, &s->group_statement.children.tail,
 				      output_section_statement,
 				      fill, dot, relax, check_regions);
 	  break;
@@ -5290,8 +5651,89 @@
 	  FAIL ();
 	  break;
 	}
-      prev = &s->header.next;
+
+     if( new_dot > dot )
+     {
+#if 0
+    	 int i;
+    	 for (i=0; i<indent; i++)
+    	 {
+    		 printf("  ");
+    	 }
+	    	switch ( s->header.type )
+	    	{
+
+	    	  case lang_output_section_statement_enum:
+	    		  printf("output section %s", s->output_section_statement.name );
+	    		  break;
+	    	  case lang_assignment_statement_enum:
+	    		  printf("assignment");
+				  break;
+	    	  case lang_input_statement_enum:
+	    	  	  printf("input %s", s->input_statement.local_sym_name );
+				  break;
+	    	  case lang_address_statement_enum:
+	    	  	  printf("address %s", s->address_statement.section_name );
+	    		  break;
+	    	  case lang_wild_statement_enum:
+	    	  	  printf("wild %s", s->wild_statement.filename );
+	    		  break;
+	    	  case lang_input_section_enum:
+	    	  	  printf("input section %s", s->input_section.section->name );
+	    		  break;
+	    	  case lang_object_symbols_statement_enum:
+	    	  	  printf("object symbols" );
+	    		  break;
+	    	  case lang_fill_statement_enum:
+	    	  	  printf("fill %d", s->fill_statement.size );
+	    		  break;
+	    	  case lang_data_statement_enum:
+	    	  	  printf("data");
+	    		  break;
+	    	  case lang_reloc_statement_enum:
+	    	  	  printf("reloc %s", s->reloc_statement.name );
+	    		  break;
+	    	  case lang_target_statement_enum:
+	    	  	  printf("target %s", s->target_statement.target );
+	    		  break;
+	    	  case lang_output_statement_enum:
+	    	  	  printf("output %s", s->output_statement.name );
+	    		  break;
+	    	  case lang_padding_statement_enum:
+	    	  	  printf("padding %d", s->padding_statement.size );
+	    		  break;
+	    	  case lang_group_statement_enum:
+	    	  	  printf("group");
+	    		  break;
+	    	  case lang_insert_statement_enum:
+	    	  	  printf("insert %s", s->insert_statement.where );
+	    		  break;
+	    	  case lang_constructors_statement_enum:
+	    	  	  printf("constructors" );
+	    		  break;
+	    	  default:
+	    		  printf("unknown");
+	    		  break;
+	    	}
+   	 	 printf(" output: %s dot:0x%08x newdot:0x%08x\n", output_section_statement->name, dot, new_dot );
+#endif
+
+	    if ( 0 == size_input_section_overflow_if_required( start, tail_ptr, output_section_statement, &s, dot, new_dot, relax, check_regions) )
+	    {
+
+			if ( bfd_section_size_needs_update == 1 )
+			{
+				output_section_statement->bfd_section->size += (new_dot - dot);
+				bfd_section_size_needs_update = 0;
+			}
+			dot = new_dot;
+	    }
+     }
+
+      head_ptr = &s->header.next;
     }
+
+  indent--;
   return dot;
 }
 
@@ -5347,7 +5789,7 @@
 one_lang_size_sections_pass (bfd_boolean *relax, bfd_boolean check_regions)
 {
   lang_statement_iteration++;
-  lang_size_sections_1 (&statement_list.head, abs_output_section,
+  lang_size_sections_1 (&statement_list.head, &statement_list.tail, abs_output_section,
 			0, 0, relax, check_regions);
 }
 
@@ -6996,7 +7438,8 @@
 void
 lang_leave_output_section_statement (fill_type *fill, const char *memspec,
 				     lang_output_section_phdr_list *phdrs,
-				     const char *lma_memspec)
+				     const char *lma_memspec,
+				     const char *ovfl_memspec)
 {
   lang_get_regions (&current_section->region,
 		    &current_section->lma_region,
@@ -7004,6 +7447,8 @@
 		    current_section->load_base != NULL,
 		    current_section->addr_tree != NULL);
 
+  current_section->ovfl_section = ovfl_memspec;
+
   /* If this section has no load region or base, but uses the same
      region as the previous section, then propagate the previous
      section's load region.  */
@@ -7351,7 +7796,7 @@
      region and that no load-time region has been specified.  It doesn't
      really matter what we say here, since lang_leave_overlay will
      override it.  */
-  lang_leave_output_section_statement (fill, DEFAULT_MEMORY_REGION, phdrs, 0);
+  lang_leave_output_section_statement (fill, DEFAULT_MEMORY_REGION, phdrs, 0, NULL);
 
   /* Define the magic symbols.  */
 
@@ -7388,7 +7833,8 @@
 		    fill_type *fill,
 		    const char *memspec,
 		    lang_output_section_phdr_list *phdrs,
-		    const char *lma_memspec)
+		    const char *lma_memspec,
+		    const char *ovfl_memspec)
 {
   lang_memory_region_type *region;
   lang_memory_region_type *lma_region;
@@ -7399,6 +7845,7 @@
 		    memspec, lma_memspec,
 		    lma_expr != NULL, FALSE);
 
+  (void)ovfl_memspec;
   nocrossref = NULL;
 
   /* After setting the size of the last section, set '.' to end of the
diff -Naur binutils-2.24/ld/ldlang.h binutils-2.24_modded/ld/ldlang.h
--- binutils-2.24/ld/ldlang.h	2013-11-05 02:33:39 +1100
+++ binutils-2.24_modded/ld/ldlang.h	2013-12-06 15:54:11 +1100
@@ -128,7 +128,9 @@
   bfd_boolean used;
 } lang_output_section_phdr_list;
 
-typedef struct lang_output_section_statement_struct
+typedef struct lang_output_section_statement_struct lang_output_section_statement_type;
+
+struct lang_output_section_statement_struct
 {
   lang_statement_header_type header;
   lang_statement_list_type children;
@@ -138,6 +140,7 @@
   asection *bfd_section;
   lang_memory_region_type *region;
   lang_memory_region_type *lma_region;
+  const char *ovfl_section;
   fill_type *fill;
   union etree_union *addr_tree;
   union etree_union *load_base;
@@ -167,7 +170,7 @@
   unsigned int after_end : 1;
   /* If this section uses the alignment of its input sections.  */
   unsigned int align_lma_with_input : 1;
-} lang_output_section_statement_type;
+};
 
 typedef struct
 {
@@ -460,7 +463,7 @@
 
 struct orphan_save
 {
-  const char *name;
+  const char *name;	
   flagword flags;
   lang_output_section_statement_type *os;
   asection **section;
@@ -534,7 +537,7 @@
   (bfd_boolean);
 extern void lang_leave_output_section_statement
   (fill_type *, const char *, lang_output_section_phdr_list *,
-   const char *);
+   const char *, const char *);
 extern void lang_statement_append
   (lang_statement_list_type *, lang_statement_union_type *,
    lang_statement_union_type **);
@@ -627,7 +630,7 @@
   (fill_type *, lang_output_section_phdr_list *);
 extern void lang_leave_overlay
   (etree_type *, int, fill_type *, const char *,
-   lang_output_section_phdr_list *, const char *);
+   lang_output_section_phdr_list *, const char *, const char *);
 
 extern struct bfd_elf_version_expr *lang_new_vers_pattern
   (struct bfd_elf_version_expr *, const char *, const char *, bfd_boolean);
diff -Naur binutils-2.24/ld/ldlex.l binutils-2.24_modded/ld/ldlex.l
--- binutils-2.24/ld/ldlex.l	2013-11-05 02:33:39 +1100
+++ binutils-2.24_modded/ld/ldlex.l	2013-12-06 15:55:12 +1100
@@ -318,6 +318,7 @@
 <EXPRESSION,BOTH,SCRIPT>"INCLUDE"	{ RTOKEN(INCLUDE);}
 <BOTH,SCRIPT>"PHDRS"			{ RTOKEN (PHDRS); }
 <EXPRESSION,BOTH,SCRIPT>"AT"		{ RTOKEN(AT);}
+<EXPRESSION,BOTH,SCRIPT>"OVERFLOW_INTO"		{ RTOKEN(OVERFLOW_INTO);}
 <EXPRESSION,BOTH,SCRIPT>"ALIGN_WITH_INPUT"	{ RTOKEN(ALIGN_WITH_INPUT);}
 <EXPRESSION,BOTH,SCRIPT>"SUBALIGN"	{ RTOKEN(SUBALIGN);}
 <EXPRESSION,BOTH,SCRIPT>"HIDDEN"	{ RTOKEN(HIDDEN); }
diff -Naur binutils-2.24/ld/Makefile.in binutils-2.24_modded/ld/Makefile.in
--- binutils-2.24/ld/Makefile.in	2013-11-26 22:37:33 +1100
+++ binutils-2.24_modded/ld/Makefile.in	2013-12-06 15:47:15 +1100
@@ -1,9 +1,9 @@
-# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# Makefile.in generated by automake 1.11.6 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
-# Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011 Free Software
+# Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -35,6 +35,23 @@
 
 
 VPATH = @srcdir@
+am__make_dryrun = \
+  { \
+    am__dry=no; \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        echo 'am--echo: ; @echo "AM"  OK' | $(MAKE) -f - 2>/dev/null \
+          | grep '^AM OK$$' >/dev/null || am__dry=yes;; \
+      *) \
+        for am__flg in $$MAKEFLAGS; do \
+          case $$am__flg in \
+            *=*|--*) ;; \
+            *n*) am__dry=yes; break;; \
+          esac; \
+        done;; \
+    esac; \
+    test $$am__dry = yes; \
+  }
 pkgdatadir = $(datadir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
@@ -126,14 +143,14 @@
 	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
 	$(LDFLAGS) -o $@
 @MAINTAINER_MODE_FALSE@am__skiplex = test -f $@ ||
-LEXCOMPILE = $(LEX) $(LFLAGS) $(AM_LFLAGS)
+LEXCOMPILE = $(LEX) $(AM_LFLAGS) $(LFLAGS)
 LTLEXCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(LEX) $(LFLAGS) $(AM_LFLAGS)
+	--mode=compile $(LEX) $(AM_LFLAGS) $(LFLAGS)
 YLWRAP = $(top_srcdir)/../ylwrap
 @MAINTAINER_MODE_FALSE@am__skipyacc = test -f $@ ||
-YACCCOMPILE = $(YACC) $(YFLAGS) $(AM_YFLAGS)
+YACCCOMPILE = $(YACC) $(AM_YFLAGS) $(YFLAGS)
 LTYACCCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
-	--mode=compile $(YACC) $(YFLAGS) $(AM_YFLAGS)
+	--mode=compile $(YACC) $(AM_YFLAGS) $(YFLAGS)
 SOURCES = $(libldtestplug_la_SOURCES) $(ld_new_SOURCES) \
 	$(EXTRA_ld_new_SOURCES)
 INFO_DEPS = ld.info
@@ -154,6 +171,11 @@
 	install-pdf-recursive install-ps-recursive install-recursive \
 	installcheck-recursive installdirs-recursive pdf-recursive \
 	ps-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
 am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
 am__vpath_adj = case $$p in \
     $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
@@ -175,6 +197,12 @@
 am__base_list = \
   sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
   sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
 man1dir = $(mandir)/man1
 NROFF = nroff
 MANS = $(man_MANS)
@@ -210,6 +238,7 @@
 DATADIRNAME = @DATADIRNAME@
 DEFS = @DEFS@
 DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
 DSYMUTIL = @DSYMUTIL@
 DUMPBIN = @DUMPBIN@
 ECHO_C = @ECHO_C@
@@ -262,6 +291,7 @@
 LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
 MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
 MKDIR_P = @MKDIR_P@
 MKINSTALLDIRS = @MKINSTALLDIRS@
 MSGFMT = @MSGFMT@
@@ -304,6 +334,7 @@
 abs_srcdir = @abs_srcdir@
 abs_top_builddir = @abs_top_builddir@
 abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_CXX = @ac_ct_CXX@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
@@ -953,7 +984,7 @@
 
 .SUFFIXES:
 .SUFFIXES: .c .dvi .l .lo .o .obj .ps .y
-am--refresh:
+am--refresh: Makefile
 	@:
 $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
 	@for dep in $?; do \
@@ -989,10 +1020,8 @@
 $(am__aclocal_m4_deps):
 
 config.h: stamp-h1
-	@if test ! -f $@; then \
-	  rm -f stamp-h1; \
-	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
-	else :; fi
+	@if test ! -f $@; then rm -f stamp-h1; else :; fi
+	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) stamp-h1; else :; fi
 
 stamp-h1: $(srcdir)/config.in $(top_builddir)/config.status
 	@rm -f stamp-h1
@@ -1015,12 +1044,15 @@
 	  echo "rm -f \"$${dir}/so_locations\""; \
 	  rm -f "$${dir}/so_locations"; \
 	done
-libldtestplug.la: $(libldtestplug_la_OBJECTS) $(libldtestplug_la_DEPENDENCIES) 
+libldtestplug.la: $(libldtestplug_la_OBJECTS) $(libldtestplug_la_DEPENDENCIES) $(EXTRA_libldtestplug_la_DEPENDENCIES) 
 	$(libldtestplug_la_LINK) $(am_libldtestplug_la_rpath) $(libldtestplug_la_OBJECTS) $(libldtestplug_la_LIBADD) $(LIBS)
 install-binPROGRAMS: $(bin_PROGRAMS)
 	@$(NORMAL_INSTALL)
-	test -z "$(bindir)" || $(MKDIR_P) "$(DESTDIR)$(bindir)"
 	@list='$(bin_PROGRAMS)'; test -n "$(bindir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(bindir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(bindir)" || exit 1; \
+	fi; \
 	for p in $$list; do echo "$$p $$p"; done | \
 	sed 's/$(EXEEXT)$$//' | \
 	while read p p1; do if test -f $$p || test -f $$p1; \
@@ -1061,16 +1093,12 @@
 	echo " rm -f" $$list; \
 	rm -f $$list
 ldgram.h: ldgram.c
-	@if test ! -f $@; then \
-	  rm -f ldgram.c; \
-	  $(MAKE) $(AM_MAKEFLAGS) ldgram.c; \
-	else :; fi
+	@if test ! -f $@; then rm -f ldgram.c; else :; fi
+	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) ldgram.c; else :; fi
 deffilep.h: deffilep.c
-	@if test ! -f $@; then \
-	  rm -f deffilep.c; \
-	  $(MAKE) $(AM_MAKEFLAGS) deffilep.c; \
-	else :; fi
-ld-new$(EXEEXT): $(ld_new_OBJECTS) $(ld_new_DEPENDENCIES) 
+	@if test ! -f $@; then rm -f deffilep.c; else :; fi
+	@if test ! -f $@; then $(MAKE) $(AM_MAKEFLAGS) deffilep.c; else :; fi
+ld-new$(EXEEXT): $(ld_new_OBJECTS) $(ld_new_DEPENDENCIES) $(EXTRA_ld_new_DEPENDENCIES) 
 	@rm -f ld-new$(EXEEXT)
 	$(LINK) $(ld_new_OBJECTS) $(ld_new_LDADD) $(LIBS)
 
@@ -1592,9 +1620,7 @@
 
 uninstall-info-am:
 	@$(PRE_UNINSTALL)
-	@if test -d '$(DESTDIR)$(infodir)' && \
-	    (install-info --version && \
-	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	@if test -d '$(DESTDIR)$(infodir)' && $(am__can_run_installinfo); then \
 	  list='$(INFO_DEPS)'; \
 	  for file in $$list; do \
 	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
@@ -1666,11 +1692,18 @@
 	done
 install-man1: $(man_MANS)
 	@$(NORMAL_INSTALL)
-	test -z "$(man1dir)" || $(MKDIR_P) "$(DESTDIR)$(man1dir)"
-	@list=''; test -n "$(man1dir)" || exit 0; \
-	{ for i in $$list; do echo "$$i"; done; \
-	l2='$(man_MANS)'; for i in $$l2; do echo "$$i"; done | \
-	  sed -n '/\.1[a-z]*$$/p'; \
+	@list1=''; \
+	list2='$(man_MANS)'; \
+	test -n "$(man1dir)" \
+	  && test -n "`echo $$list1$$list2`" \
+	  || exit 0; \
+	echo " $(MKDIR_P) '$(DESTDIR)$(man1dir)'"; \
+	$(MKDIR_P) "$(DESTDIR)$(man1dir)" || exit 1; \
+	{ for i in $$list1; do echo "$$i"; done;  \
+	if test -n "$$list2"; then \
+	  for i in $$list2; do echo "$$i"; done \
+	    | sed -n '/\.1[a-z]*$$/p'; \
+	fi; \
 	} | while read p; do \
 	  if test -f $$p; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; echo "$$p"; \
@@ -1699,9 +1732,7 @@
 	  sed -n '/\.1[a-z]*$$/p'; \
 	} | sed -e 's,.*/,,;h;s,.*\.,,;s,^[^1][0-9a-z]*$$,1,;x' \
 	      -e 's,\.[0-9a-z]*$$,,;$(transform);G;s,\n,.,'`; \
-	test -z "$$files" || { \
-	  echo " ( cd '$(DESTDIR)$(man1dir)' && rm -f" $$files ")"; \
-	  cd "$(DESTDIR)$(man1dir)" && rm -f $$files; }
+	dir='$(DESTDIR)$(man1dir)'; $(am__uninstall_files_from_dir)
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -1837,12 +1868,12 @@
 
 distclean-tags:
 	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
-site.exp: Makefile
+site.exp: Makefile $(EXTRA_DEJAGNU_SITE_CONFIG)
 	@echo 'Making a new site.exp file...'
 	@echo '## these variables are automatically generated by make ##' >site.tmp
 	@echo '# Do not edit here.  If you wish to override these values' >>site.tmp
 	@echo '# edit the last section' >>site.tmp
-	@echo 'set srcdir $(srcdir)' >>site.tmp
+	@echo 'set srcdir "$(srcdir)"' >>site.tmp
 	@echo "set objdir `pwd`" >>site.tmp
 	@echo 'set build_alias "$(build_alias)"' >>site.tmp
 	@echo 'set build_triplet $(build_triplet)' >>site.tmp
@@ -1850,9 +1881,16 @@
 	@echo 'set host_triplet $(host_triplet)' >>site.tmp
 	@echo 'set target_alias "$(target_alias)"' >>site.tmp
 	@echo 'set target_triplet $(target_triplet)' >>site.tmp
-	@echo '## All variables above are generated by configure. Do Not Edit ##' >>site.tmp
-	@test ! -f site.exp || \
-	  sed '1,/^## All variables above are.*##/ d' site.exp >> site.tmp
+	@list='$(EXTRA_DEJAGNU_SITE_CONFIG)'; for f in $$list; do \
+	  echo "## Begin content included from file $$f.  Do not modify. ##" \
+	   && cat `test -f "$$f" || echo '$(srcdir)/'`$$f \
+	   && echo "## End content included from file $$f. ##" \
+	   || exit 1; \
+	 done >> site.tmp
+	@echo "## End of auto-generated content; you can edit from here. ##" >> site.tmp
+	@if test -f site.exp; then \
+	   sed -e '1,/^## End of auto-generated content.*##/d' site.exp >> site.tmp; \
+	 fi
 	@-rm -f site.bak
 	@test ! -f site.exp || mv site.exp site.bak
 	@mv site.tmp site.exp
@@ -1884,10 +1922,15 @@
 
 installcheck: installcheck-recursive
 install-strip:
-	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
-	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
-	  `test -z '$(STRIP)' || \
-	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
 mostlyclean-generic:
 	-test -z "$(MOSTLYCLEANFILES)" || rm -f $(MOSTLYCLEANFILES)
 
@@ -1940,8 +1983,11 @@
 
 install-dvi-am: $(DVIS)
 	@$(NORMAL_INSTALL)
-	test -z "$(dvidir)" || $(MKDIR_P) "$(DESTDIR)$(dvidir)"
 	@list='$(DVIS)'; test -n "$(dvidir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(dvidir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(dvidir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -1956,18 +2002,22 @@
 
 install-html-am: $(HTMLS)
 	@$(NORMAL_INSTALL)
-	test -z "$(htmldir)" || $(MKDIR_P) "$(DESTDIR)$(htmldir)"
 	@list='$(HTMLS)'; list2=; test -n "$(htmldir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(htmldir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(htmldir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p" || test -d "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  $(am__strip_dir) \
-	  if test -d "$$d$$p"; then \
+	  d2=$$d$$p; \
+	  if test -d "$$d2"; then \
 	    echo " $(MKDIR_P) '$(DESTDIR)$(htmldir)/$$f'"; \
 	    $(MKDIR_P) "$(DESTDIR)$(htmldir)/$$f" || exit 1; \
-	    echo " $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'"; \
-	    $(INSTALL_DATA) "$$d$$p"/* "$(DESTDIR)$(htmldir)/$$f" || exit $$?; \
+	    echo " $(INSTALL_DATA) '$$d2'/* '$(DESTDIR)$(htmldir)/$$f'"; \
+	    $(INSTALL_DATA) "$$d2"/* "$(DESTDIR)$(htmldir)/$$f" || exit $$?; \
 	  else \
-	    list2="$$list2 $$d$$p"; \
+	    list2="$$list2 $$d2"; \
 	  fi; \
 	done; \
 	test -z "$$list2" || { echo "$$list2" | $(am__base_list) | \
@@ -1979,9 +2029,12 @@
 
 install-info-am: $(INFO_DEPS)
 	@$(NORMAL_INSTALL)
-	test -z "$(infodir)" || $(MKDIR_P) "$(DESTDIR)$(infodir)"
 	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
 	list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(infodir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(infodir)" || exit 1; \
+	fi; \
 	for file in $$list; do \
 	  case $$file in \
 	    $(srcdir)/*) file=`echo "$$file" | sed "s|^$$srcdirstrip/||"`;; \
@@ -1999,8 +2052,7 @@
 	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(infodir)'"; \
 	  $(INSTALL_DATA) $$files "$(DESTDIR)$(infodir)" || exit $$?; done
 	@$(POST_INSTALL)
-	@if (install-info --version && \
-	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
+	@if $(am__can_run_installinfo); then \
 	  list='$(INFO_DEPS)'; test -n "$(infodir)" || list=; \
 	  for file in $$list; do \
 	    relfile=`echo "$$file" | sed 's|^.*/||'`; \
@@ -2014,8 +2066,11 @@
 
 install-pdf-am: $(PDFS)
 	@$(NORMAL_INSTALL)
-	test -z "$(pdfdir)" || $(MKDIR_P) "$(DESTDIR)$(pdfdir)"
 	@list='$(PDFS)'; test -n "$(pdfdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(pdfdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(pdfdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
@@ -2027,8 +2082,11 @@
 
 install-ps-am: $(PSS)
 	@$(NORMAL_INSTALL)
-	test -z "$(psdir)" || $(MKDIR_P) "$(DESTDIR)$(psdir)"
 	@list='$(PSS)'; test -n "$(psdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(psdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(psdir)" || exit 1; \
+	fi; \
 	for p in $$list; do \
 	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
 	  echo "$$d$$p"; \
diff -Naur binutils-2.24/ld/mri.c binutils-2.24_modded/ld/mri.c
--- binutils-2.24/ld/mri.c	2013-11-05 02:33:39 +1100
+++ binutils-2.24_modded/ld/mri.c	2013-12-06 15:47:15 +1100
@@ -231,7 +231,7 @@
 		lang_add_wild (NULL, tmp, FALSE);
 	      }
 
-	  lang_leave_output_section_statement (0, "*default*", NULL, NULL);
+	  lang_leave_output_section_statement (0, "*default*", NULL, NULL, NULL);
 
 	  p = p->next;
 	}
